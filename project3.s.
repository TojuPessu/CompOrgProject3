.data
    emptyInput: .asciiz "Input is empty." #message for string with an empty input
    longInput: .asciiz "Input it is too long." #messgae for string that has more than 4 characters
    invalidInput: .asciiz "Invalid base-35 number." #message for string that includes one or more characters not in set
    userI: .space 1000
.text
    main:
        li $v0, 8 #syscall to read string
        la $a0, userI #stores address of string
        li $a1, 500 #create ample space for string input
        syscall
        add $t0, $0, 0 #initialize $t0 register
        add $t1, $0, 0 #initialize $t1 register

        la $t2, userI 
        lb $t0, 0($t2)
        beq $t0, 10, isEmpty #check for an empty string
        beq $t0, 0 isEmpty

        addi $s0, $0, 35 #store Base-N number
        addi $t3, $0, 1 #initialize new registers
        addi $t4, $0, 0
        addi $t5, $0, 0

        ignoreSpaces:
            lb $t0, 0($t2) #load address in $t2 to $t0
            addi $t2, $t2, 1 #increment pointer
            addi $t1, $t1, 1 #increment counter
            beq $t0, 32, ignoreSpaces 
            beq $t0, 10, isEmpty 
            beq $t0, $0, isEmpty 

        viewChars:
            lb $t0, 0($t2)
            addi $t2, $t2, 1
            addi $t1, $t1, 1
            beq $t0, 10, restart
            beq $t0, 0, restart
            bne $t0, 32, viewChars

        viewRemaining:
            lb $t0, 0($t2)
            addi $t2, $t2, 1
            addi $t1, $t1, 1
            beq $t0, 10, restart
            beq $t0, 0, restart
            bne $t0, 32, itsInvalid 
            j viewRemaining

        restart:
            sub $t2, $t2, $t1 #restart the pointer
            la $t1, 0 #restart the counter

        continue:
            lb $t0, 0($t2)
            addi $t2, $t2, 1
            beq $t0, 32, continue
        addi $t2, $t2, -1

        stringLength:
            lb $t0, ($t2)
            addi $t2, $t2, 1
            addi $t1, $t1, 1
            beq $t0, 10, callconversion
            beq $t0, 0, callconversion
            beq $t0, 32, callconversion
            beq $t1, 5, isTooLong
            j stringLength

callconversion:
    sub $t2, $t2, $t1 #move ptr back to start of string
    addi $sp, $sp, -4 #allocating memory for stack
    sw $ra, 0($sp) #only return address
    move $a0, $t2
    li $a1, 3  
    li $a2, 1 
    jal DeciVersion 

    #print result
    move $a0, $v0
    li $v0, 1
    syscall
    
    lw $ra, 0($sp) 
    addi $sp, $sp, 4 #deallocating the memory
    jr $ra

        end:
            move $a0, $t5 #move value to $a0
            li $v0, 1 #print value
            syscall
            li $v0, 10 #end program
            syscall

        isEmpty:
            la $a0, emptyInput 
            li $v0, 4 
            syscall
            
            li $v0, 10 #end of program
            syscall
            
       isTooLong:
            la $a0, longInput 
            li $v0, 4 #prints string
            syscall

            li $v0, 10 #end of program
            syscall










